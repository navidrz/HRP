# بهینه‌سازی پرتفو با استفاده از HRP و CVaR

### روایت این پروژه

در عرصه پرتلاطم سرمایه‌گذاری، مدیریت پرتفوی و کاهش ریسک همواره از اهمیت بالایی برخوردار بوده‌اند. این پروژه، تلاشی است برای ارائه یک راه‌حل جامع و علمی جهت بهینه‌سازی پرتفوی سرمایه‌گذاری با استفاده از روش نوین **Hierarchical Risk Parity (HRP)**. در این روایت، نه تنها تلاش‌های دقیق برای پیاده‌سازی این راهکارها را به اشتراک خواهم گذاشت، بلکه جزئیات فنی و تصمیمات کلیدی مرتبط با فرآیند توسعه را نیز تشریح خواهم کرد.


![Hierarchical Risk Parity](https://raw.githubusercontent.com/navidrz/HRP/61e7ca6321b3747c83355dbf648f8de61b04f3e1/Hierarchical%20Risk%20Parity.png "Hierarchical Risk Parity Diagram")

### نگاهی به ایده اصلی

بهینه‌سازی پرتفوی از مسائل اصلی فعالان مالی و سرمایه‌گذاران بوده است. هدف اصلی، ایجاد توازن بین بازده و ریسک است؛ توازنی که با توجه به شرایط متغیر بازار، بیشترین بازده را در سطح قابل قبولی از ریسک به ارمغان آورد. این پروژه در جستجوی پاسخی علمی برای این نیاز است؛ پاسخی که از تکنیک‌های نوین و مبتنی بر داده استفاده می‌کند.

### فرآیند انتخاب ترکیب‌های بهینه

#### تولید ترکیب‌های پرتفو

اولین گام در این فرآیند، انتخاب ترکیب‌هایی از نمادهای موجود برای تحلیل بود. با استفاده از روش‌های برنامه‌نویسی و کتابخانه‌هایی مانند `itertools`، تمامی ترکیب‌های ممکن از نمادها تولید شد. این رویکرد به ما امکان داد تمامی حالات ممکن را به دقت بررسی کنیم:


```python
def generate_combinations(symbol_ids: list, portfolio_size: int = 10) -> list:
    return list(itertools.combinations(symbol_ids, portfolio_size))
```

هرچند این رویکرد از نظر تئوری کامل بود، اما به دلیل تعداد زیاد ترکیب‌ها، نیاز به ایجاد محدودیت‌هایی در تعداد نمونه‌ها احساس شد.

---

#### محدود کردن حجم ترکیب‌ها

به دلیل منابع محدود محاسباتی، تعداد ترکیب‌های انتخاب‌شده برای تحلیل، به کمک روش‌های نمونه‌گیری تصادفی به یک مقدار قابل مدیریت محدود شد. این رویکرد ضمن حفظ دقت، کارایی سیستم را نیز افزایش داد:

```python
desired_samples = 100000  # تعداد نمونه‌های مورد نظر
if total_combinations > desired_samples:
    sampled_combinations = random.sample(portfolio_combinations, desired_samples)
else:
    sampled_combinations = portfolio_combinations
```

---

### بارگذاری و پردازش داده‌ها

#### استفاده از کلاس DataFetcher

برای شروع، نیاز به داده‌هایی از قیمت‌های تاریخی نمادها بود. این داده‌ها به کمک کلاسی با عنوان `DataFetcher` و از طریق APIهای موجود جمع‌آوری شدند. این کلاس مسئولیت داشت که داده‌ها را پاک‌سازی و استانداردسازی کند تا برای تحلیل‌های بعدی آماده شوند:

```python
class DataFetcher:
    """کلاسی برای دریافت و پردازش داده‌ها از API."""
```

##### جزئیات عملکرد

1. **دریافت داده‌های تاریخی:** این داده‌ها به‌صورت روزانه برای هر نماد جمع‌آوری شدند.
2. **تبدیل تاریخ‌ها:** تاریخ‌های جلالی به میلادی تبدیل شدند تا سازگاری داده‌ها تضمین شود.
3. **پاک‌سازی داده‌ها:** داده‌های نامعتبر حذف شدند.
4. **بازگشت داده‌ها:** خروجی، یک `DataFrame` استاندارد و آماده برای استفاده در تحلیل‌ها بود.

---

#### مدیریت داده‌های چندگانه

برای مدیریت هم‌زمان داده‌های چندین نماد، از رویکرد پردازش موازی استفاده شد. این روش امکان بارگذاری سریع‌تر و کارآمدتر داده‌ها را فراهم کرد:

```python
@staticmethod
async def fetch_all_symbols(symbol_ids: list) -> dict:
    tasks = [DataFetcher.fetch_daily_history(symbol_id) for symbol_id in symbol_ids]
    results = await asyncio.gather(*tasks)
    return dict(zip(symbol_ids, results))
```

---

### گام دوم: پیش‌پردازش داده‌ها

در این مرحله، داده‌های خام جمع‌آوری‌شده از منابع مختلف باید به اطلاعاتی تبدیل شوند که برای تحلیل‌های پیشرفته مناسب باشند. این فرآیند شامل مراحل کلیدی مانند محاسبه بازده‌ها، پاک‌سازی داده‌ها و هم‌ترازی مجموعه‌های مختلف است. در این بخش، کلاس‌های اصلی برای مدیریت و آماده‌سازی داده‌ها معرفی می‌شوند.

---

### کلاس Preprocessor: ابزاری برای آماده‌سازی داده‌ها

این کلاس مسئول اصلی پیش‌پردازش داده‌ها است. هدف آن، استانداردسازی داده‌های ورودی و آماده‌سازی مجموعه‌های آموزشی و تست است. پیش‌پردازش دقیق، بنیان تحلیل‌های موفق در مراحل بعدی را شکل می‌دهد.

#### محاسبه بازده‌ها

برای تحلیل‌های مالی، بازده‌های روزانه نمادها یکی از ورودی‌های کلیدی هستند. کلاس `Preprocessor` از یک متد برای محاسبه بازده‌های درصدی استفاده می‌کند:

```python
@staticmethod
def calculate_returns(prices: pd.DataFrame) -> pd.DataFrame:
    """محاسبه بازده‌های روزانه از داده‌های قیمت."""
    returns = prices.pct_change().dropna()
    return returns
```

##### گام‌های انجام‌شده:
1. **محاسبه بازده‌های درصدی:** با استفاده از `pct_change` بازده‌های روزانه به‌دست آمد.
2. **حذف داده‌های نامعتبر:** مقادیر خالی حذف شدند تا دقت محاسبات تضمین شود.

---

#### هم‌ترازی مجموعه‌های داده

با توجه به اینکه داده‌های ورودی از منابع مختلف ممکن است دارای بازه‌های زمانی متفاوت باشند، لازم است که همه مجموعه‌ها بر اساس تاریخ‌های مشترک هم‌تراز شوند. این کار به کمک متدی اختصاصی انجام می‌شود:

```python
@staticmethod
def align_datasets(*datasets: pd.DataFrame) -> pd.DataFrame:
    """هم‌ترازی مجموعه‌های داده بر اساس تاریخ‌های مشترک."""
    common_dates = set.intersection(*(set(ds.index) for ds in datasets))
    aligned_datasets = [ds.loc[common_dates].sort_index() for ds in datasets]
    return pd.concat(aligned_datasets, axis=1).dropna()
```

##### گام‌های انجام‌شده:
1. **یافتن تاریخ‌های مشترک:** تاریخ‌های موجود در تمامی مجموعه‌های داده مشخص شدند.
2. **استخراج داده‌های هم‌تراز:** داده‌های موجود در تاریخ‌های مشترک استخراج شدند.
3. **ترکیب داده‌ها:** مجموعه‌های داده در یک ساختار یکپارچه ترکیب و داده‌های نامعتبر حذف شدند.

---

#### آماده‌سازی داده‌های آموزشی و تست

برای آموزش و ارزیابی مدل‌ها، داده‌ها باید به دو بخش مجزا تقسیم شوند. متد زیر این وظیفه را بر عهده دارد:

```python
@staticmethod
def process_data(prices: pd.DataFrame, market_returns: pd.Series, risk_free_rate: pd.Series,
                 market_cap: pd.Series, usd_to_rial: pd.Series) -> tuple:
    """پردازش داده‌ها و آماده‌سازی مجموعه‌های آموزشی و تست."""
    returns = Preprocessor.calculate_returns(prices)
    aligned_data = Preprocessor.align_datasets(returns, market_returns, risk_free_rate, market_cap, usd_to_rial)
    X = aligned_data.iloc[:, :-3]
    y = aligned_data.iloc[:, -3:]
    return train_test_split(X, y, test_size=0.33, random_state=42)
```

##### گام‌های انجام‌شده:
1. **محاسبه بازده‌ها:** بازده‌های روزانه نمادها به کمک متد `calculate_returns` محاسبه شدند.
2. **هم‌ترازی داده‌ها:** تمامی مجموعه‌های داده بر اساس تاریخ‌های مشترک هم‌تراز شدند.
3. **تعریف ویژگی‌ها و متغیر هدف:** 
   - **ویژگی‌ها (X):** بازده‌های نمادها.
   - **متغیر هدف (y):** بازده‌های اضافی بازار و سایر متغیرهای اقتصادی.
4. **تقسیم داده‌ها:** داده‌ها به دو بخش آموزشی و تست تقسیم شدند.

---

### گام سوم: ورود به دنیای مدل‌های بهینه‌سازی

اکنون که داده‌های ما آماده شده‌اند، زمان آن است که مدل‌های بهینه‌سازی پیشرفته‌ای مانند **Hierarchical Risk Parity (HRP)** و **Conditional Value at Risk (CVaR)** را معرفی کرده و به کار ببریم. این مدل‌ها با هدف توزیع بهینه ریسک و کاهش خطرات سیستماتیک، برای ایجاد پرتفوهایی با بازدهی مطلوب طراحی شده‌اند.

---

### معرفی کلاس OptimizerModel

کلاس `OptimizerModel` ابزاری جامع برای تعریف، آموزش و پیش‌بینی مدل‌های بهینه‌سازی است. این کلاس به شکلی طراحی شده که بتواند به طور پویا از مدل‌های مختلفی مانند HRP یا CVaR پشتیبانی کند.

#### مقداردهی اولیه (Initialization)

در ابتدای تعریف هر نمونه از این کلاس، مشخصات مدل مانند نوع بهینه‌سازی و نام آن تعیین می‌شود:

```python
class OptimizerModel:
    def __init__(self, optimizer, name="Optimizer-Model"):
        self.name = name
        self.optimizer = optimizer
```

---

#### برازش مدل (Fitting the Model)

این متد، مدل را بر روی داده‌های آموزشی برازش می‌دهد. برای مدل‌هایی مانند HRP، فرآیند خوشه‌بندی سلسله‌مراتبی و محاسبه ماتریس همبستگی در این مرحله انجام می‌شود:

```python
def fit(self, X_train: pd.DataFrame, y_train: pd.DataFrame = None):
    if "HRP" in self.name:
        correlation_matrix = X_train.corr(method='pearson')
        distance_matrix = 1 - correlation_matrix
        self.optimizer.fit(distance_matrix)
    else:
        self.optimizer.fit(X_train, y_train)
```

##### مراحل کلیدی:
1. **محاسبه ماتریس همبستگی:** برای مدل HRP، ماتریس همبستگی بین نمادها محاسبه می‌شود.
2. **محاسبه ماتریس فاصله:** ماتریس فاصله از طریق تبدیل همبستگی‌ها محاسبه می‌شود.
3. **خوشه‌بندی سلسله‌مراتبی:** خوشه‌بندی سلسله‌مراتبی بر اساس ماتریس فاصله اجرا می‌شود.
4. **برازش مدل:** مدل‌های دیگر مانند CVaR از داده‌های بازده و متغیرهای هدف برای برازش استفاده می‌کنند.

---

#### پیش‌بینی وزن‌های پرتفو

پس از برازش مدل، وزن‌های پرتفو با استفاده از داده‌های تست پیش‌بینی می‌شوند. این وزن‌ها نشان‌دهنده سهم بهینه هر نماد در پرتفو هستند:

```python
def predict(self, X: pd.DataFrame):
    return self.optimizer.predict(X)
```

##### ویژگی‌ها:
- وزن‌های پرتفو متناسب با معیارهای ریسک و بازده محاسبه می‌شوند.
- وزن‌ها به صورت یک `Series` بازگردانده می‌شوند که شاخص‌های آن نمادها هستند.

---

### تعریف مدل‌های HRP

برای تعریف مدل‌های HRP، از ترکیبی از روش‌های لینکج و تخمین‌گرهای فاصله استفاده می‌شود. هر ترکیب، رویکردی متفاوت برای خوشه‌بندی و توزیع ریسک ارائه می‌دهد:

```python
linkage_methods = [LinkageMethod.SINGLE, LinkageMethod.COMPLETE, LinkageMethod.AVERAGE, LinkageMethod.WARD]
distance_estimators = [(None, "Pearson"), (KendallDistance(absolute=True), "Kendall")]

for linkage in linkage_methods:
    for distance_estimator, distance_name in distance_estimators:
        model_name = f"HRP-{linkage.value.capitalize()}-{distance_name}"
        optimizer = HierarchicalRiskParity(
            risk_measure=RiskMeasure.CVAR,
            distance_estimator=distance_estimator,
            hierarchical_clustering_estimator=HierarchicalClustering(linkage_method=linkage)
        )
        model = OptimizerModel(optimizer=optimizer, name=model_name)
        models.append(model)
```

##### مراحل کلیدی:
1. **تعریف روش‌های لینکج:** شامل روش‌هایی مانند `SINGLE`, `COMPLETE`, `AVERAGE`, و `WARD`.
2. **تعریف تخمین‌گرهای فاصله:** شامل `Pearson` و `Kendall`.
3. **ایجاد مدل HRP برای هر ترکیب:** هر مدل با یک روش لینکج و یک تخمین‌گر فاصله مشخص تعریف می‌شود.

---

### مدل Distributionally Robust CVaR

این مدل به‌عنوان یک رویکرد پیشرفته‌تر، از ترکیبی از معیارهای ریسک و خوشه‌بندی بهره می‌برد. در اینجا، از تخمین‌گر **Factor Model** برای ارزیابی داده‌های پرتفو استفاده شده است:

```python
optimizer4 = DistributionallyRobustCVaR(
    risk_aversion=1.0,
    cvar_beta=0.95,
    wasserstein_ball_radius=0.02,
    prior_estimator=FactorModel(),
    min_weights=0.0,
    max_weights=1.0,
    budget=1.0
)
model4 = OptimizerModel(optimizer=optimizer4, name="DistributionallyRobustCVaR-Factor-Model")
models.append(model4)
```

##### ویژگی‌ها:
- از معیارهای ریسک CVaR و رویکرد توزیع‌محور استفاده می‌کند.
- با استفاده از `FactorModel`، اولویت‌ها در خوشه‌بندی مشخص می‌شوند.

---

### گام چهارم: تحلیل و ارزیابی مدل‌ها

پس از تعریف و برازش مدل‌ها، نوبت به ارزیابی عملکرد آن‌ها می‌رسد. این مرحله شامل پیش‌بینی وزن‌های پرتفو، تحلیل مشارکت ریسک، و بررسی متریک‌های عملکردی مانند **Sharpe Ratio** و **Sortino Ratio** است. ارزیابی دقیق به ما کمک می‌کند تا میزان کارایی مدل‌های بهینه‌سازی را بسنجیم و پرتفوهای برتر را شناسایی کنیم.

---

### تحلیل مشارکت ریسک

هدف از این تحلیل، شناسایی سهم هر نماد در کل ریسک پرتفو است. با استفاده از معیارهایی مانند **CVaR** یا **Variance**، می‌توان مشخص کرد که کدام نمادها بیشترین سهم از ریسک پرتفو را به خود اختصاص داده‌اند.

#### پیاده‌سازی تحلیل مشارکت ریسک

برای هر مدل، پس از پیش‌بینی وزن‌های پرتفو، سهم ریسک هر نماد محاسبه می‌شود:

```python
portfolio = model.predict(X_train)
if portfolio is not None:
    evaluator.analyze_risk_contribution(portfolio, measure=RiskMeasure.CVAR)
```

##### مراحل کلیدی:
1. **پیش‌بینی وزن‌ها:** با استفاده از داده‌های آموزشی، وزن‌های پرتفو برای هر مدل محاسبه می‌شوند.
2. **محاسبه مشارکت ریسک:** سهم هر نماد از کل ریسک پرتفو، متناسب با وزن و معیار انتخاب‌شده (مانند CVaR)، تعیین می‌شود.
3. **ترسیم نمودار مشارکت ریسک:** نتایج به‌صورت بصری نمایش داده می‌شوند تا تحلیل دقیق‌تری انجام شود.

---

### پیش‌بینی پرتفو و تحلیل وزن‌ها

پس از برازش مدل‌ها، وزن‌های پرتفو با استفاده از داده‌های تست پیش‌بینی می‌شوند. این وزن‌ها مشخص می‌کنند که چه میزان از سرمایه باید به هر نماد اختصاص یابد.

#### پیش‌بینی وزن‌های پرتفو

```python
portfolio = model.predict(X_test)
if portfolio is not None:
    logger.info(f"Weights for model {model.name}: {portfolio.weights}")
```

##### ویژگی‌ها:
- وزن‌های پیش‌بینی‌شده با توجه به داده‌های تست محاسبه می‌شوند.
- نتایج به صورت وزن‌های درصدی ارائه می‌شوند و مجموع وزن‌ها برابر با ۱ خواهد بود.

---

### ارزیابی متریک‌های عملکردی

متریک‌های عملکردی به ما کمک می‌کنند تا میزان موفقیت هر مدل در بهینه‌سازی پرتفو را بسنجیم. در اینجا از متریک‌هایی مانند **Sharpe Ratio**, **Sortino Ratio**, **VaR** و **CVaR** استفاده شده است.

#### محاسبه متریک‌ها

```python
metrics = Evaluator.calculate_performance_metrics(portfolio_returns, risk_free_rate=avg_risk_free_rate)
```

##### مراحل کلیدی:
1. **محاسبه بازده اضافی:** بازده‌های پرتفو نسبت به نرخ بدون ریسک محاسبه می‌شوند.
2. **Sharpe Ratio:** نسبت بازده اضافی به نوسانات کلی پرتفو.
3. **Sortino Ratio:** نسبت بازده اضافی به نوسانات نزولی پرتفو.
4. **VaR و CVaR:** حد ضرر و انتظار ضرر در شرایطی که VaR نقض شده است.

---

### ترسیم نمودارهای عملکرد

#### بازده‌های تجمعی

یکی از بهترین روش‌ها برای ارزیابی عملکرد پرتفو، بررسی بازده‌های تجمعی در طول زمان است. این بازده‌ها به ما نشان می‌دهند که پرتفو در مجموع چه میزان بازدهی ایجاد کرده است.

```python
evaluator.plot_cumulative_returns(population_test)
```

#### ترکیب پرتفو

ترکیب پرتفو نیز می‌تواند اطلاعات مفیدی درباره تنوع و توزیع سرمایه‌گذاری ارائه دهد:

```python
evaluator.plot_composition(population_test)
```

---

### خلاصه‌سازی نتایج و رتبه‌بندی پرتفوها

پس از محاسبه متریک‌های عملکردی، پرتفوها بر اساس معیارهایی مانند **Sharpe Ratio** رتبه‌بندی می‌شوند.

#### رتبه‌بندی پرتفوها

```python
ranking_df = summary.loc["Annualized Sharpe Ratio"].sort_values(ascending=False).head(5)
```

##### ویژگی‌ها:
- پرتفوها بر اساس معیار انتخاب‌شده مرتب می‌شوند.
- پنج پرتفو برتر به‌صورت جداگانه مشخص و تحلیل می‌شوند.

---

### خروجی گرفتن از نتایج

برای دسترسی آسان‌تر، نتایج به‌صورت فایل‌های CSV و Excel ذخیره می‌شوند:

```python
weights_df.to_csv('Optimized_Portfolio_Weights.csv', index=False, encoding='utf-8-sig')
weights_df.to_excel('Optimized_Portfolio_Weights.xlsx', index=False, engine='openpyxl')
```

![Photo 7](https://raw.githubusercontent.com/navidrz/HRP/61e7ca6321b3747c83355dbf648f8de61b04f3e1/photo_7_2024-11-20_20-19-39.jpg "Photo 7")


### چگونه نمودار دندروگرام و ماتریس همبستگی HRP را بخوانید!


ابزارهایی مانند نمودار دندروگرام و ماتریس همبستگی، دریچه‌ای جدید به درک عمیق‌تر روابط میان دارایی‌ها می‌گشایند. این ابزارها، نقشه‌ای روشن از نحوه خوشه‌بندی دارایی‌ها و میزان ارتباط میان آن‌ها ارائه می‌دهند و به سرمایه‌گذاران کمک می‌کنند پرتفوهایی بهینه‌تر و کم‌ریسک‌تر طراحی کنند. به زبان ساده‌تر، با کمک این تحلیل‌ها، می‌توان میان انبوهی از دارایی‌ها، روابط پنهان را شناسایی کرد و تصمیم‌هایی دقیق‌تر و هوشمندانه‌تر اتخاذ نمود. در این نوشتار، قصد دارم شما را با جنبه‌های مختلف این تحلیل آشنا کنم.

دندروگرام، نموداری است که با ساختار سلسله‌مراتبی خود، دارایی‌ها را بر اساس میزان شباهت یا همبستگی خوشه‌بندی می‌کند. در اینجا، هر خوشه مانند شاخه‌ای از یک درخت است که گروهی از دارایی‌های مرتبط را در خود جای می‌دهد. در کنار آن، ماتریس همبستگی نقش تکمیل‌کننده‌ای دارد و با رنگ‌آمیزی دقیق، شدت ارتباط میان دارایی‌ها را نشان می‌دهد. هر مربع در این ماتریس، داستانی از همبستگی را روایت می‌کند؛ مربع‌های روشن‌تر از ارتباط قوی‌تر و مربع‌های تیره‌تر از ارتباط ضعیف‌تر حکایت دارند. این ابزارها به ما امکان می‌دهند که ریسک را بهتر توزیع کنیم و دارایی‌هایی با کمترین ارتباط را برای کاهش خطرات در پرتفو انتخاب نماییم.

![Photo 5](https://raw.githubusercontent.com/navidrz/HRP/61e7ca6321b3747c83355dbf648f8de61b04f3e1/photo_5_2024-11-20_20-19-39.jpg "Photo 5")


![Photo 3](https://raw.githubusercontent.com/navidrz/HRP/61e7ca6321b3747c83355dbf648f8de61b04f3e1/photo_3_2024-11-20_20-19-39.jpg "Photo 3")



نکته جذاب‌تر، نحوه تغییرات خوشه‌بندی در تصاویر مختلف است. در برخی نمودارها، خوشه‌ها کوچک‌تر و دقیق‌ترند، گویی ذره‌بینی بر جزئیات ارتباط دارایی‌ها نهاده شده است. در دیگر تصاویر، خوشه‌ها بزرگ‌تر و فراگیرترند، که برای مدیریت کلی‌تر پرتفو بسیار کارآمد هستند. مربع‌های زرد در ماتریس همبستگی، مرزهایی واضح میان این خوشه‌ها ترسیم می‌کنند و نشان می‌دهند که کدام دارایی‌ها رفتار مشابهی دارند. این تحلیل‌ها، به‌ویژه برای سرمایه‌گذاران حرفه‌ای، ابزاری بی‌بدیل به شمار می‌آیند که می‌توانند بر اساس آن، استراتژی‌های متنوع‌تری طراحی کرده و پرتفوهای خود را از تهدیدهای ناگهانی مصون نگه دارند.


دندروگرام و ماتریس همبستگی، زبان پنهان دارایی‌ها را آشکار می‌سازند و به سرمایه‌گذاران اجازه می‌دهند تا با تکیه بر داده‌های دقیق، تصمیماتی مبتنی بر عقلانیت و مدیریت ریسک اتخاذ کنند. این ابزارها، نقشه‌ای برای یافتن مسیرهای کم‌خطرتر در میان نوسانات بازار هستند و راه‌حلی برای ایجاد تعادل میان تنوع دارایی‌ها و کاهش خطرات به شمار می‌آیند. سرمایه‌گذارانی که این زبان را می‌فهمند، در میدان پرچالش اقتصاد، گامی مطمئن‌تر برمی‌دارند.







---

### گام پنجم: جمع‌بندی و نتیجه‌گیری

اکنون که تمامی مراحل از جمع‌آوری داده‌ها تا تعریف، برازش، ارزیابی و تحلیل مدل‌ها انجام شده است، می‌توان تصویری جامع از این پروژه ارائه داد. هدف ما از این مسیر، طراحی و پیاده‌سازی ابزارهایی برای بهینه‌سازی پرتفو بود که بتوانند در شرایط متغیر بازار، عملکردی قابل‌اعتماد و مطمئن ارائه دهند.

---




### دستاوردهای کلیدی پروژه

1. **پیاده‌سازی دقیق و جامع روش‌های نوین بهینه‌سازی:**
   - استفاده از روش‌های پیشرفته‌ای همچون **Hierarchical Risk Parity (HRP)** و **Conditional Value at Risk (CVaR)**، امکان توزیع ریسک بهینه و مدیریت آن را فراهم کرد.
   - مدل‌های مبتنی بر خوشه‌بندی سلسله‌مراتبی و اولویت‌بندی فاکتوری توانستند وزن‌های دقیقی برای پرتفوها ارائه دهند.

2. **تحلیل مشارکت ریسک و ارزیابی متریک‌های عملکردی:**
   - محاسبه متریک‌هایی مانند **Sharpe Ratio**, **Sortino Ratio**, و **CVaR**، بینشی عمیق درباره عملکرد هر مدل ارائه داد.
   - تحلیل مشارکت ریسک نشان داد که کدام نمادها سهم بیشتری در ریسک پرتفو دارند و چگونه می‌توان این سهم‌ها را بهینه کرد.

3. **رشد بازدهی و کاهش نوسانات:**
   - پرتفوهای پیشنهادی توانستند بازدهی بالاتری نسبت به معیارهای مرجع ارائه دهند، در حالی که سطح ریسک در محدوده‌ای معقول نگه داشته شد.

4. **کارایی بالا با پردازش موازی:**
   - استفاده از پردازش موازی و غیرهمزمان، زمان محاسبات را به‌طور چشمگیری کاهش داد و کارایی سیستم را بهبود بخشید.

---

### چالش‌ها و راه‌حل‌ها

1. **حجم زیاد ترکیب‌ها:**
   - چالش اصلی در این پروژه، حجم بالای ترکیب‌های ممکن از نمادها بود. با اعمال نمونه‌گیری تصادفی، این چالش مدیریت شد و امکان تحلیل ترکیب‌های متنوع فراهم شد.

2. **کیفیت داده‌های ورودی:**
   - در برخی موارد، داده‌های ناقص یا نامعتبر وجود داشتند. با اعمال پیش‌پردازش دقیق، این داده‌ها پاک‌سازی و استانداردسازی شدند.

3. **تنظیم دقیق مدل‌ها:**
   - مدل‌هایی مانند **Distributionally Robust CVaR** نیاز به پارامترهای دقیق داشتند. با تست و ارزیابی مکرر، تنظیمات بهینه برای هر مدل به‌دست آمد.

---


### نتیجه‌گیری نهایی

این پروژه گامی مهم در راستای استفاده از تکنولوژی‌های پیشرفته برای بهینه‌سازی پرتفوهای سرمایه‌گذاری بود. روش‌های مورد استفاده نشان دادند که چگونه می‌توان با ترکیب داده‌ها، الگوریتم‌های پیشرفته و تحلیل‌های دقیق، راه‌حل‌هایی علمی برای چالش‌های بازار ارائه کرد.

در نهایت، ابزار طراحی‌شده در این پروژه نه تنها برای سرمایه‌گذاران حرفه‌ای، بلکه برای مدیران پرتفو و پژوهشگران مالی نیز ارزشمند است و می‌تواند به‌عنوان نقطه شروعی برای بهینه‌سازی‌های پیشرفته‌تر مورد استفاده قرار گیرد.

---

### سپاسگزاری

از توجه شما به این پروژه متشکرم. اگر سؤالی دارید یا به اطلاعات بیشتری نیاز دارید، خوشحال خواهم شد که به آن‌ها پاسخ دهم. 

دوستدار شما 
نوید رمضانی

